// This file was generated by counterfeiter
package fakes

import (
	"sync"
	"../../os_helper"
)

type FakeOsHelper struct {
	RunCommandStub        func(executable string, args ...string) (string, error)
	runCommandMutex       sync.RWMutex
	runCommandArgsForCall []struct {
		executable string
		args       []string
	}
	runCommandReturns struct {
		result1 string
		result2 error
	}
	RunCommandPanicOnErrStub        func(executable string, args ...string) string
	runCommandPanicOnErrMutex       sync.RWMutex
	runCommandPanicOnErrArgsForCall []struct {
		executable string
		args       []string
	}
	runCommandPanicOnErrReturns struct {
		result1 string
	}
	FileExistsStub        func(filename string) bool
	fileExistsMutex       sync.RWMutex
	fileExistsArgsForCall []struct {
		filename string
	}
	fileExistsReturns struct {
		result1 bool
	}
	ReadFileStub        func(filename string) (string, error)
	readFileMutex       sync.RWMutex
	readFileArgsForCall []struct {
		filename string
	}
	readFileReturns struct {
		result1 string
		result2 error
	}
	WriteStringToFileStub        func(filename string, contents string) error
	writeStringToFileMutex       sync.RWMutex
	writeStringToFileArgsForCall []struct {
		filename string
		contents string
	}
	writeStringToFileReturns struct {
		result1 error
	}
}

func (fake *FakeOsHelper) RunCommand(executable string, args ...string) (string, error) {
	fake.runCommandMutex.Lock()
	defer fake.runCommandMutex.Unlock()
	fake.runCommandArgsForCall = append(fake.runCommandArgsForCall, struct {
		executable string
		args       []string
	}{executable, args})
	if fake.RunCommandStub != nil {
		return fake.RunCommandStub(executable, args...)
	} else {
		return fake.runCommandReturns.result1, fake.runCommandReturns.result2
	}
}

func (fake *FakeOsHelper) RunCommandCallCount() int {
	fake.runCommandMutex.RLock()
	defer fake.runCommandMutex.RUnlock()
	return len(fake.runCommandArgsForCall)
}

func (fake *FakeOsHelper) RunCommandArgsForCall(i int) (string, []string) {
	fake.runCommandMutex.RLock()
	defer fake.runCommandMutex.RUnlock()
	return fake.runCommandArgsForCall[i].executable, fake.runCommandArgsForCall[i].args
}

func (fake *FakeOsHelper) RunCommandReturns(result1 string, result2 error) {
	fake.RunCommandStub = nil
	fake.runCommandReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOsHelper) RunCommandPanicOnErr(executable string, args ...string) string {
	fake.runCommandPanicOnErrMutex.Lock()
	defer fake.runCommandPanicOnErrMutex.Unlock()
	fake.runCommandPanicOnErrArgsForCall = append(fake.runCommandPanicOnErrArgsForCall, struct {
		executable string
		args       []string
	}{executable, args})
	if fake.RunCommandPanicOnErrStub != nil {
		return fake.RunCommandPanicOnErrStub(executable, args...)
	} else {
		return fake.runCommandPanicOnErrReturns.result1
	}
}

func (fake *FakeOsHelper) RunCommandPanicOnErrCallCount() int {
	fake.runCommandPanicOnErrMutex.RLock()
	defer fake.runCommandPanicOnErrMutex.RUnlock()
	return len(fake.runCommandPanicOnErrArgsForCall)
}

func (fake *FakeOsHelper) RunCommandPanicOnErrArgsForCall(i int) (string, []string) {
	fake.runCommandPanicOnErrMutex.RLock()
	defer fake.runCommandPanicOnErrMutex.RUnlock()
	return fake.runCommandPanicOnErrArgsForCall[i].executable, fake.runCommandPanicOnErrArgsForCall[i].args
}

func (fake *FakeOsHelper) RunCommandPanicOnErrReturns(result1 string) {
	fake.RunCommandPanicOnErrStub = nil
	fake.runCommandPanicOnErrReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeOsHelper) FileExists(filename string) bool {
	fake.fileExistsMutex.Lock()
	defer fake.fileExistsMutex.Unlock()
	fake.fileExistsArgsForCall = append(fake.fileExistsArgsForCall, struct {
		filename string
	}{filename})
	if fake.FileExistsStub != nil {
		return fake.FileExistsStub(filename)
	} else {
		return fake.fileExistsReturns.result1
	}
}

func (fake *FakeOsHelper) FileExistsCallCount() int {
	fake.fileExistsMutex.RLock()
	defer fake.fileExistsMutex.RUnlock()
	return len(fake.fileExistsArgsForCall)
}

func (fake *FakeOsHelper) FileExistsArgsForCall(i int) string {
	fake.fileExistsMutex.RLock()
	defer fake.fileExistsMutex.RUnlock()
	return fake.fileExistsArgsForCall[i].filename
}

func (fake *FakeOsHelper) FileExistsReturns(result1 bool) {
	fake.FileExistsStub = nil
	fake.fileExistsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOsHelper) ReadFile(filename string) (string, error) {
	fake.readFileMutex.Lock()
	defer fake.readFileMutex.Unlock()
	fake.readFileArgsForCall = append(fake.readFileArgsForCall, struct {
		filename string
	}{filename})
	if fake.ReadFileStub != nil {
		return fake.ReadFileStub(filename)
	} else {
		return fake.readFileReturns.result1, fake.readFileReturns.result2
	}
}

func (fake *FakeOsHelper) ReadFileCallCount() int {
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	return len(fake.readFileArgsForCall)
}

func (fake *FakeOsHelper) ReadFileArgsForCall(i int) string {
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	return fake.readFileArgsForCall[i].filename
}

func (fake *FakeOsHelper) ReadFileReturns(result1 string, result2 error) {
	fake.ReadFileStub = nil
	fake.readFileReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOsHelper) WriteStringToFile(filename string, contents string) error {
	fake.writeStringToFileMutex.Lock()
	defer fake.writeStringToFileMutex.Unlock()
	fake.writeStringToFileArgsForCall = append(fake.writeStringToFileArgsForCall, struct {
		filename string
		contents string
	}{filename, contents})
	if fake.WriteStringToFileStub != nil {
		return fake.WriteStringToFileStub(filename, contents)
	} else {
		return fake.writeStringToFileReturns.result1
	}
}

func (fake *FakeOsHelper) WriteStringToFileCallCount() int {
	fake.writeStringToFileMutex.RLock()
	defer fake.writeStringToFileMutex.RUnlock()
	return len(fake.writeStringToFileArgsForCall)
}

func (fake *FakeOsHelper) WriteStringToFileArgsForCall(i int) (string, string) {
	fake.writeStringToFileMutex.RLock()
	defer fake.writeStringToFileMutex.RUnlock()
	return fake.writeStringToFileArgsForCall[i].filename, fake.writeStringToFileArgsForCall[i].contents
}

func (fake *FakeOsHelper) WriteStringToFileReturns(result1 error) {
	fake.WriteStringToFileStub = nil
	fake.writeStringToFileReturns = struct {
		result1 error
	}{result1}
}

var _ os_helper.OsHelper = new(FakeOsHelper)
